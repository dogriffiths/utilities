<!DOCTYPE html>
<html>
<head>
    <title>Simple TODO App</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js" defer></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 20px auto;
            padding: 20px;
            position: relative; /* Add this for overlay positioning */
        }

        .todo-container, .journal-container {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        #newTask {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #45a049;
        }

        .task-list, .journal-list {
            list-style: none;
            padding: 0;
        }

        .task-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: white;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: move;
        }

        .task-metadata {
            display: flex;
            gap: 12px;
            font-size: 0.8em;
            color: #666;
        }

        .task-metadata span {
            white-space: nowrap;
        }

        .task-text {
            flex-grow: 1;
            cursor: pointer;
        }

        .task-description {
            font-size: 0.8em;
            color: #666;
            margin-top: 4px;
        }

        .task-due-date {
            font-size: 0.8em;
            color: #666;
        }

        .task-due-date.overdue {
            color: #ff4444;
        }

        .task-comments {
            font-size: 0.8em;
            color: #666;
            padding-left: 0;
            border-left: 2px solid #eee;
        }

        .task-item:hover .delete-button {
            display: block;
        }

        .task-checkbox {
            margin-right: 10px;
        }

        .dragging {
            opacity: 0.5;
        }

        #status {
            color: #666;
            font-size: 0.9em;
            margin-top: 10px;
            text-align: center;
        }

        /* Dialog styles */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
        }

        .dialog {
            background: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
        }

        .dialog input,
        .dialog textarea {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .dialog textarea {
            height: 100px;
            resize: vertical;
        }

        .dialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .dialog-buttons button.cancel {
            background: #666;
        }

        .comment-input {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .comment-input input {
            flex-grow: 1;
        }

        .comments-list {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .comment-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }

        .comment-date {
            font-size: 0.8em;
            color: #888;
        }

        .page-drop-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(76, 175, 80, 0.2);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            pointer-events: none;
        }

        .page-drop-overlay.visible {
            display: flex;
        }

        .page-drop-message {
            background: white;
            padding: 20px 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 2px dashed #4CAF50;
            font-size: 1.2em;
            color: #4CAF50;
        }

        .journal-day {
            margin-bottom: 20px;
        }

        .journal-day-header {
            font-weight: bold;
            color: #666;
            padding: 10px 0;
            border-bottom: 2px solid #eee;
            margin-bottom: 10px;
        }

        .journal-item {
            display: flex;
            padding: 8px;
            background: white;
            margin-bottom: 5px;
            border-radius: 4px;
            align-items: flex-start;
        }

        .journal-time {
            color: #666;
            font-size: 0.9em;
            min-width: 80px;
        }

        .journal-content {
            flex-grow: 1;
        }

        .journal-title {
            font-weight: 500;
        }

        .journal-description {
            font-size: 0.9em;
            color: #666;
            margin-top: 4px;
        }

        .delete-button {
            opacity: 0.6;
            padding: 4px;
            background: none;
            border: none;
            cursor: pointer;
            color: #666;
            display: none;
        }

        .delete-button:hover {
            opacity: 1;
            color: #ff4444;
        }

        .delete-confirmation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .delete-confirmation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }

        .tabs {
            display: flex;
            border-bottom: 2px solid #eee;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 16px;
            color: #666;
            position: relative;
        }

        .tab.active {
            color: #4CAF50;
        }

        .tab:hover {
            color: white;
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: #4CAF50;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
<div class="tabs">
    <button class="tab active" data-tab="tasks">Tasks</button>
    <button class="tab" data-tab="schedule">Schedule</button>
</div>
<div id="tasks-tab" class="tab-content active">
    <div class="todo-container">
        <h2>TODO List</h2>
        <div class="input-container">
            <input type="text" id="newTask" placeholder="Enter a new task">
            <button onclick="addTask()">Add Task</button>
        </div>
        <ul id="taskList" class="task-list">
        </ul>
        <div id="status"></div>
    </div>
</div>
<div id="schedule-tab" class="tab-content">
    <div class="journal-container">
        <h2>Journal</h2>
        <div id="journalList" class="journal-list">
        </div>
    </div>
</div>

<!-- Edit Dialog -->
<div id="editDialog" class="dialog-overlay">
    <div class="dialog">
        <h3>Edit Task</h3>
        <div class="form-group">
            <label for="editTaskText">Task Title</label>
            <input type="text" id="editTaskText" placeholder="Task title">
        </div>

        <div class="form-group">
            <label for="editTaskDueDate">Due Date</label>
            <input type="datetime-local" id="editTaskDueDate">
        </div>

        <div class="form-group">
            <label for="editTaskDescription">Description</label>
            <textarea id="editTaskDescription" placeholder="Task description"></textarea>
        </div>

        <div class="comments-section">
            <h4>Comments</h4>
            <div class="comments-list" id="commentsList"></div>
            <div class="comment-input">
                <input type="text" id="newComment" placeholder="Add a comment">
                <button onclick="addComment()">Add</button>
            </div>
        </div>

        <div class="dialog-buttons">
            <button class="cancel" onclick="closeEditDialog()">Cancel</button>
            <button onclick="saveEditedTask()">Save</button>
        </div>
    </div>
</div>
<div id="pageDropOverlay" class="page-drop-overlay">
    <div class="page-drop-message">
        Drop your OPML, CSV, or TXT file here
    </div>
</div>


<script>
    let db = null;
    const DB_NAME = 'TodoDB';
    const STORE_NAME = 'todos';
    const COMPLETED_STORE = 'completed';
    let currentEditingId = null;

    // Initialize database connection
    initDB().catch(error => {
        console.error('Database initialization failed:', error);
        showStatus('Database initialization failed', true);
    });

    async function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, 3); // Increased version number for schema update

            request.onerror = (event) => {
                console.error('Database error:', event.target.error);
                reject(event.target.error);
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                console.log('Database opened successfully');
                loadTasks();
                loadJournal();
                resolve(db);
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    const store = db.createObjectStore(STORE_NAME, {keyPath: 'id', autoIncrement: true});
                    store.createIndex('position', 'position', {unique: false});
                    store.createIndex('description', 'description', {unique: false});
                    store.createIndex('dueDate', 'dueDate', {unique: false});
                    console.log('Object store created');
                } else if (event.oldVersion < 2) {
                    // Add description field to existing store
                    const store = event.target.transaction.objectStore(STORE_NAME);
                    if (!store.indexNames.contains('description')) {
                        store.createIndex('description', 'description', {unique: false});
                    }
                    if (!store.indexNames.contains('comments')) {
                        store.createIndex('comments', 'comments', {unique: false});
                    }
                } else if (event.oldVersion < 3) {
                    const store = event.target.transaction.objectStore(STORE_NAME);
                    if (!store.indexNames.contains('dueDate')) {
                        store.createIndex('dueDate', 'dueDate', {unique: false});
                    }
                }
                if (!db.objectStoreNames.contains(COMPLETED_STORE)) {
                    const completedStore = db.createObjectStore(COMPLETED_STORE, {keyPath: 'id', autoIncrement: true});
                    completedStore.createIndex('completedAt', 'completedAt', {unique: false});
                }
            };
        });
    }

    function showStatus(message, isError = false) {
        const status = document.getElementById('status');
        status.textContent = message;
        status.style.color = isError ? '#ff4444' : '#666';
        setTimeout(() => {
            status.textContent = '';
        }, 3000);
    }

    async function loadTasks() {
        if (!db) {
            console.error('Database not initialized');
            return;
        }

        try {
            const transaction = db.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.getAll();

            request.onsuccess = () => {
                const tasks = request.result;
                const taskList = document.getElementById('taskList');
                taskList.innerHTML = '';

                tasks
                    .sort((a, b) => a.position - b.position)
                    .forEach(task => {
                        const li = createTaskElement(task);
                        taskList.appendChild(li);
                    });

                console.log('Tasks loaded:', tasks.length);
            };

            request.onerror = (event) => {
                console.error('Error loading tasks:', event.target.error);
                showStatus('Error loading tasks', true);
            };
        } catch (error) {
            console.error('Error in loadTasks:', error);
            showStatus('Error loading tasks', true);
        }
    }

    async function addTask() {
        if (!db) {
            console.error('Database not initialized');
            showStatus('Database not ready', true);
            return;
        }

        const input = document.getElementById('newTask');
        const taskText = input.value.trim();

        if (taskText === '') return;

        try {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);

            const countRequest = store.count();

            countRequest.onsuccess = () => {
                const position = countRequest.result;

                const task = {
                    text: taskText,
                    description: '',
                    comments: [], // Initialize empty comments array
                    position: position,
                    created: new Date().toISOString()
                };

                const addRequest = store.add(task);

                addRequest.onsuccess = (event) => {
                    const taskId = event.target.result;
                    task.id = taskId;
                    const taskList = document.getElementById('taskList');
                    const li = createTaskElement(task);
                    taskList.appendChild(li);
                    input.value = '';
                    showStatus('Task added successfully');
                };

                addRequest.onerror = (event) => {
                    console.error('Error adding task:', event.target.error);
                    showStatus('Error adding task', true);
                };
            };
        } catch (error) {
            console.error('Error in addTask:', error);
            showStatus('Error adding task', true);
        }
    }

    function createTaskElement(task) {
        const li = document.createElement('li');
        li.className = 'task-item';
        li.draggable = true;
        li.dataset.id = task.id;
        li.dataset.position = task.position;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'task-checkbox';
        checkbox.onclick = function () {
            if (this.checked) {
                deleteTask(task.id);
            }
        };

        const textContainer = document.createElement('div');
        textContainer.className = 'task-text';
        textContainer.onclick = () => openEditDialog(task);

        const titleSpan = document.createElement('span');
        titleSpan.textContent = task.text;
        textContainer.appendChild(titleSpan);

        const descSpan = document.createElement('div');
        descSpan.className = 'task-description';
        descSpan.textContent = task.description;
        textContainer.appendChild(descSpan);

        // Create a metadata container for due date and comments
        const metadataContainer = document.createElement('div');
        metadataContainer.className = 'task-metadata';
        metadataContainer.style.cssText = 'display: flex; gap: 12px; font-size: 0.8em; color: #666; margin-top: 4px;';

        // Add due date if exists
        const dueDateSpan = document.createElement('span');
        dueDateSpan.className = 'task-dueDate';
        dueDateSpan.style.cssText = 'white-space: nowrap;';
        if (task.dueDate) {
            const date = new Date(task.dueDate);
            const isOverdue = date < new Date();
            dueDateSpan.style.color = isOverdue ? '#ff4444' : '#666';
            dueDateSpan.innerHTML = `📅 ${date.toLocaleString(undefined, {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            })}`;
        } else {
            dueDateSpan.style.cssText += ' height: 0';
        }
        metadataContainer.appendChild(dueDateSpan);

        // Add comments count
        const commentsSpan = document.createElement('span');
        commentsSpan.className = 'task-comments-augmented';

        // Add comments preview if there are any
        if (task.comments && task.comments.length > 0) {
            commentsSpan.innerHTML = `💬 <span class="task-comments">${task.comments.length}</span>`;
        } else {
            commentsSpan.innerHTML = `<span class="task-comments"/>`;
            commentsSpan.style.cssText += ' height: 0';
        }
        metadataContainer.appendChild(commentsSpan);

        // Add metadata container to text container
        textContainer.appendChild(metadataContainer);

        const deleteButton = document.createElement('button');
        deleteButton.className = 'delete-button ml-2';
        deleteButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>';
        deleteButton.onclick = (e) => {
            e.stopPropagation(); // Prevent opening edit dialog
            confirmDelete(task);
        };

        li.appendChild(checkbox);
        li.appendChild(textContainer);
        li.appendChild(deleteButton)

        li.addEventListener('dragstart', handleDragStart);
        li.addEventListener('dragend', handleDragEnd);
        li.addEventListener('dragover', handleDragOver);
        li.addEventListener('drop', handleDrop);

        return li;
    }

    function openEditDialog(task) {
        currentEditingId = task.id;
        const dialog = document.getElementById('editDialog');
        const taskText = document.getElementById('editTaskText');
        const taskDesc = document.getElementById('editTaskDescription');
        const taskDueDate = document.getElementById('editTaskDueDate');
        const commentsList = document.getElementById('commentsList');

        taskText.value = task.text;
        taskDesc.value = task.description || '';
        if (task.dueDate) {
            const date = new Date(task.dueDate);
            const formattedDate = date.toISOString().slice(0, 16);
            taskDueDate.value = formattedDate;
        } else {
            taskDueDate.value = '';
        }

        // Load comments
        commentsList.innerHTML = '';
        if (task.comments && task.comments.length > 0) {
            task.comments.forEach(comment => {
                const commentDiv = document.createElement('div');
                commentDiv.className = 'comment-item';
                commentDiv.innerHTML = `
                    <div class="comment-text">${comment.text}</div>
                    <div class="comment-date">${new Date(comment.date).toLocaleString()}</div>
                `;
                commentsList.appendChild(commentDiv);
            });
        }

        dialog.style.display = 'flex';
        document.getElementById('newComment').value = '';
    }

    function closeEditDialog() {
        const dialog = document.getElementById('editDialog');
        dialog.style.display = 'none';
        currentEditingId = null;
    }

    async function addComment() {
        if (!db || !currentEditingId) return;

        const commentInput = document.getElementById('newComment');
        const commentText = commentInput.value.trim();

        if (commentText === '') return;

        try {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get(currentEditingId);

            request.onsuccess = () => {
                const task = request.result;
                if (!task.comments) task.comments = [];

                const newComment = {
                    text: commentText,
                    date: new Date().toISOString()
                };

                task.comments.push(newComment);

                store.put(task).onsuccess = () => {
                    // Add comment to UI
                    const commentsList = document.getElementById('commentsList');
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'comment-item';
                    commentDiv.innerHTML = `
                        <div class="comment-text">${newComment.text}</div>
                        <div class="comment-date">${new Date(newComment.date).toLocaleString()}</div>
                    `;
                    commentsList.appendChild(commentDiv);

                    // Clear input
                    commentInput.value = '';
                    showStatus('Comment added successfully');
                };
            };
        } catch (error) {
            console.error('Error adding comment:', error);
            showStatus('Error adding comment', true);
        }
    }

    async function saveEditedTask() {
        if (!db || !currentEditingId) return;

        const taskText = document.getElementById('editTaskText').value.trim();
        const taskDesc = document.getElementById('editTaskDescription').value.trim();
        const taskDueDate = document.getElementById('editTaskDueDate').value;

        if (taskText === '') return;

        try {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get(currentEditingId);

            request.onsuccess = () => {
                const task = request.result;
                task.text = taskText;
                task.description = taskDesc;
                task.dueDate = taskDueDate ? new Date(taskDueDate).toISOString() : null;

                // Note: We don't need to explicitly preserve comments here since
                // we're only updating the text and description fields of the existing task object
                // The comments array is preserved as it's not being overwritten

                store.put(task).onsuccess = () => {
                    loadTasks();
                    closeEditDialog();
                    showStatus('Task updated successfully');
                };
            };

            request.onerror = (event) => {
                console.error('Error updating task:', event.target.error);
                showStatus('Error updating task', true);
            };
        } catch (error) {
            console.error('Error saving edited task:', error);
            showStatus('Error updating task', true);
        }
    }

    async function deleteTask(id) {
        if (!db) return;

        try {
            const transaction = db.transaction([STORE_NAME, COMPLETED_STORE], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const completedStore = transaction.objectStore(COMPLETED_STORE);

            // Get the task before deleting
            const getRequest = store.get(id);

            getRequest.onsuccess = () => {
                const task = getRequest.result;
                if (task) {
                    // Add completion timestamp
                    const completedTask = {
                        ...task,
                        completedAt: new Date().toISOString()
                    };

                    // Add to completed store
                    completedStore.add(completedTask);

                    // Delete from todos store
                    store.delete(id);

                    // Update UI
                    const element = document.querySelector(`[data-id="${id}"]`);
                    if (element) {
                        element.remove();
                    }

                    // Reload journal
                    loadJournal();
                    showStatus('Task completed successfully');
                }
            };
        } catch (error) {
            console.error('Error completing task:', error);
            showStatus('Error completing task', true);
        }
    }

    async function updatePositions() {
        if (!db) return;

        try {
            const taskList = document.getElementById('taskList');
            const items = Array.from(taskList.children);
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);

            for (let index = 0; index < items.length; index++) {
                const item = items[index];
                const id = parseInt(item.dataset.id);
                const request = store.get(id);

                request.onsuccess = () => {
                    const task = request.result;
                    if (task) {
                        task.position = index;
                        store.put(task);
                    }
                };
            }

            transaction.oncomplete = () => {
                console.log('Positions updated successfully');
                showStatus('Order updated');
            };
        } catch (error) {
            console.error('Error updating positions:', error);
            showStatus('Error updating order', true);
        }
    }

    let draggedItem = null;

    function handleDragStart(e) {
        draggedItem = this;
        this.classList.add('dragging');
    }

    function handleDragEnd(e) {
        this.classList.remove('dragging');
        updatePositions();
    }

    function handleDragOver(e) {
        e.preventDefault();
    }

    function handleDrop(e) {
        e.preventDefault();
        if (this === draggedItem) return;

        let taskList = document.getElementById('taskList');
        let children = Array.from(taskList.children);
        let draggedIndex = children.indexOf(draggedItem);
        let droppedIndex = children.indexOf(this);

        if (draggedIndex < droppedIndex) {
            this.parentNode.insertBefore(draggedItem, this.nextSibling);
        } else {
            this.parentNode.insertBefore(draggedItem, this);
        }
    }

    function parseTextToTasks(textContent) {
        // Split the text content into lines and filter out empty lines
        const lines = textContent.split(/\r?\n/)
            .map(line => line.trim())
            .filter(line => line.length > 0);

        // Convert lines to task objects
        return lines.map((line, index) => {
            // Check for optional due date in parentheses at the end
            const dueDateMatch = line.match(/(.*?)\s*\(([^)]+)\)\s*$/);
            let taskText = line;
            let dueDate = null;

            if (dueDateMatch) {
                taskText = dueDateMatch[1].trim();
                const parsedDate = parseRelativeDate(dueDateMatch[2].trim());
                if (parsedDate) {
                    dueDate = parsedDate.toISOString();
                }
            }

            // Check for description after "--" separator
            const parts = taskText.split('--').map(part => part.trim());
            const title = parts[0];
            const description = parts[1] || '';

            return {
                text: title,
                description: description,
                dueDate: dueDate,
                comments: [],
                position: index,
                created: new Date().toISOString()
            };
        });
    }

    function parseOPMLToTasks(opmlText) {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(opmlText, "text/xml");
        const tasks = [];

        // Function to recursively process outline elements
        function processOutlines(elements, parentPath = []) {
            Array.from(elements).forEach(outline => {
                const text = outline.getAttribute("text") || "";
                const children = outline.getElementsByTagName("outline");

                // Only process if this is a leaf node (no children) and has text
                if (children.length === 0 && text.trim()) {
                    // Create the full path to this task for the description
                    const fullPath = [...parentPath, text.trim()];

                    // Create task object
                    const task = {
                        text: text.trim(),
                        description: '',
                        comments: [],
                        position: tasks.length,
                        created: new Date().toISOString()
                    };
                    tasks.push(task);
                }

                // Continue traversing even if we didn't add this node
                if (children.length > 0) {
                    processOutlines(children, [...parentPath, text.trim()]);
                }
            });
        }

        const outlines = xmlDoc.getElementsByTagName("outline");
        processOutlines(outlines);
        return tasks;
    }

    async function importTasks(tasks) {
        if (!db) return;

        try {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);

            // Get current highest position
            const countRequest = store.count();

            countRequest.onsuccess = async () => {
                const startPosition = countRequest.result;

                // Add each task
                for (let i = 0; i < tasks.length; i++) {
                    const task = tasks[i];
                    task.position = startPosition + i;

                    await new Promise((resolve, reject) => {
                        const request = store.add(task);
                        request.onsuccess = resolve;
                        request.onerror = reject;
                    });
                }

                // Reload tasks and show status
                loadTasks();
                showStatus(`Imported ${tasks.length} leaf tasks successfully`);
            };
        } catch (error) {
            console.error('Error importing tasks:', error);
            showStatus('Error importing tasks', true);
        }
    }

    function parseRelativeDate(dateStr) {
        if (!dateStr) return null;

        // Handle ISO format dates directly
        if (dateStr.includes('T') || dateStr.includes('-')) {
            return new Date(dateStr);
        }

        // Parse relative dates
        const match = dateStr.toLowerCase().match(/in (\d+) (day|days|week|weeks|month|months|year|years)/);
        if (!match) return null;

        const amount = parseInt(match[1]);
        const unit = match[2];

        const now = new Date();
        switch (unit) {
            case 'day':
            case 'days':
                return new Date(now.setDate(now.getDate() + amount));
            case 'week':
            case 'weeks':
                return new Date(now.setDate(now.getDate() + (amount * 7)));
            case 'month':
            case 'months':
                return new Date(now.setMonth(now.getMonth() + amount));
            case 'year':
            case 'years':
                return new Date(now.setFullYear(now.getFullYear() + amount));
            default:
                return null;
        }
    }

    function parseCSVToTasks(csvText) {
        return new Promise((resolve, reject) => {
            Papa.parse(csvText, {
                header: true,
                skipEmptyLines: true,
                transformHeader: header => header.trim().toUpperCase(),
                complete: function (results) {
                    if (results.errors.length > 0) {
                        reject(new Error('CSV parsing error: ' + results.errors[0].message));
                        return;
                    }

                    // Validate required CONTENT column
                    if (!results.meta.fields.includes('CONTENT')) {
                        reject(new Error('CSV must contain a CONTENT column'));
                        return;
                    }

                    const tasks = results.data.map((row, index) => {
                        // Skip rows without content
                        if (!row.CONTENT) return null;

                        const task = {
                            text: row.CONTENT.trim(),
                            description: row.DESCRIPTION?.trim() || '',
                            comments: [],
                            position: index,
                            created: new Date().toISOString()
                        };

                        // Handle due date if present
                        if (row.DATE) {
                            const dueDate = parseRelativeDate(row.DATE);
                            if (dueDate) {
                                task.dueDate = dueDate.toISOString();
                            }
                        }

                        return task;
                    }).filter(task => task !== null); // Remove any skipped rows

                    resolve(tasks);
                },
                error: function (error) {
                    reject(new Error('CSV parsing error: ' + error.message));
                }
            });
        });
    }

    function setupDropZone() {
        const pageOverlay = document.getElementById('pageDropOverlay');

        // Function to handle file processing
        async function processFile(file) {
            if (!file) {
                showStatus('Please drop a valid file', true);
                return;
            }

            const fileExt = file.name.toLowerCase().split('.').pop();
            if (!['opml', 'csv', 'txt'].includes(fileExt)) {
                showStatus('Please drop an OPML, CSV, or TXT file', true);
                return;
            }

            try {
                const text = await file.text();
                let tasks;

                switch (fileExt) {
                    case 'opml':
                        tasks = parseOPMLToTasks(text);
                        break;
                    case 'csv':
                        tasks = await parseCSVToTasks(text);
                        break;
                    case 'txt':
                        tasks = parseTextToTasks(text);
                        break;
                }

                await importTasks(tasks);
            } catch (error) {
                console.error(`Error processing ${fileExt.toUpperCase()} file:`, error);
                showStatus(`Error processing ${fileExt.toUpperCase()} file: ${error.message}`, true);
            }
        }

        // Page-wide drag and drop handlers
        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
            pageOverlay.classList.add('visible');
        });

        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.addEventListener('dragleave', (e) => {
            e.preventDefault();
            // Only hide overlay if leaving the document
            if (!e.relatedTarget || e.relatedTarget.nodeName === 'HTML') {
                pageOverlay.classList.remove('visible');
            }
        });

        document.addEventListener('drop', async (e) => {
            e.preventDefault();
            pageOverlay.classList.remove('visible');
            const file = e.dataTransfer.files[0];
            await processFile(file);
        });
    }

    async function loadJournal() {
        if (!db) return;

        try {
            const transaction = db.transaction(COMPLETED_STORE, 'readonly');
            const store = transaction.objectStore(COMPLETED_STORE);
            const index = store.index('completedAt');

            // Get all completed tasks sorted by completion date
            const request = index.getAll();

            request.onsuccess = () => {
                const tasks = request.result.sort((a, b) =>
                    new Date(b.completedAt) - new Date(a.completedAt)
                );

                // Group tasks by day
                const groupedTasks = groupTasksByDay(tasks);

                // Update UI
                const journalList = document.getElementById('journalList');
                journalList.innerHTML = '';

                for (const [day, dayTasks] of Object.entries(groupedTasks)) {
                    const dayDiv = document.createElement('div');
                    dayDiv.className = 'journal-day';

                    const dayHeader = document.createElement('div');
                    dayHeader.className = 'journal-day-header';
                    dayHeader.textContent = formatDay(day);
                    dayDiv.appendChild(dayHeader);

                    dayTasks.forEach(task => {
                        const taskDiv = createJournalItem(task);
                        dayDiv.appendChild(taskDiv);
                    });

                    journalList.appendChild(dayDiv);
                }
            };
        } catch (error) {
            console.error('Error loading journal:', error);
            showStatus('Error loading journal', true);
        }
    }

    function groupTasksByDay(tasks) {
        const groups = {};
        tasks.forEach(task => {
            const day = task.completedAt.split('T')[0];
            if (!groups[day]) {
                groups[day] = [];
            }
            groups[day].push(task);
        });
        return groups;
    }

    function formatDay(dateStr) {
        const date = new Date(dateStr);
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);

        if (dateStr === today.toISOString().split('T')[0]) {
            return 'Today';
        } else if (dateStr === yesterday.toISOString().split('T')[0]) {
            return 'Yesterday';
        } else {
            return date.toLocaleDateString(undefined, {
                weekday: 'long',
                month: 'long',
                day: 'numeric'
            });
        }
    }

    function createJournalItem(task) {
        const div = document.createElement('div');
        div.className = 'journal-item';

        const timeDiv = document.createElement('div');
        timeDiv.className = 'journal-time';
        timeDiv.textContent = new Date(task.completedAt).toLocaleTimeString(undefined, {
            hour: '2-digit',
            minute: '2-digit'
        });

        const contentDiv = document.createElement('div');
        contentDiv.className = 'journal-content';

        const titleDiv = document.createElement('div');
        titleDiv.className = 'journal-title';
        titleDiv.textContent = task.text;

        contentDiv.appendChild(titleDiv);

        if (task.description) {
            const descDiv = document.createElement('div');
            descDiv.className = 'journal-description';
            descDiv.textContent = task.description;
            contentDiv.appendChild(descDiv);
        }

        div.appendChild(timeDiv);
        div.appendChild(contentDiv);

        return div;
    }

    async function confirmDelete(task) {
        const confirmed = await showDeleteConfirmation(task.text);
        console.log('XXXXXX confirmed', confirmed)
        if (confirmed) {
            await permanentlyDeleteTask(task.id);
        }
    }

    function showDeleteConfirmation(taskText) {
        return new Promise((resolve) => {
            const overlay = document.createElement('div');
            overlay.className = 'delete-confirmation-overlay';

            const dialog = document.createElement('div');
            dialog.className = 'delete-confirmation';
            dialog.innerHTML = `
            <h3 style="margin-top: 0;">Delete Task</h3>
            <p>Are you sure you want to delete "${taskText}"?</p>
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button class="cancel-delete" style="background: #666;">Cancel</button>
                <button class="confirm-delete" style="background: #ff4444;">Delete</button>
            </div>
        `;

            // Add event listeners after creating the elements
            const cancelButton = dialog.querySelector('.cancel-delete');
            const confirmButton = dialog.querySelector('.confirm-delete');

            cancelButton.addEventListener('click', () => {
                overlay.remove();
                resolve(false);
            });

            confirmButton.addEventListener('click', () => {
                overlay.remove();
                resolve(true);
            });

            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
        });
    }

    async function permanentlyDeleteTask(id) {
        if (!db) return;

        try {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);

            await new Promise((resolve, reject) => {
                const request = store.delete(id);
                request.onsuccess = resolve;
                request.onerror = reject;
            });

            // Update UI
            const element = document.querySelector(`[data-id="${id}"]`);
            if (element) {
                element.remove();
            }

            showStatus('Task deleted successfully');
        } catch (error) {
            console.error('Error deleting task:', error);
            showStatus('Error deleting task', true);
        }
    }

    function setupTabs() {
        const tabs = document.querySelectorAll('.tab');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and content
                tabs.forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });

                // Add active class to clicked tab and corresponding content
                tab.classList.add('active');
                const tabId = `${tab.dataset.tab}-tab`;
                document.getElementById(tabId).classList.add('active');
            });
        });
    }


    document.addEventListener('DOMContentLoaded', () => {
        setupTabs();
        setupDropZone();

        document.getElementById('newTask').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addTask();
            }
        });

        // Add keyboard support for dialog
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeEditDialog();
            }
            if (e.key === 'Enter' && e.ctrlKey) {
                if (document.getElementById('editDialog').style.display === 'flex') {
                    saveEditedTask();
                }
            }
        });
    });
</script>
</body>
</html>