<!DOCTYPE html>
<html>
<head>
    <title>Simple TODO App</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 20px auto;
            padding: 20px;
        }

        .todo-container {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        #newTask {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #45a049;
        }

        .task-list {
            list-style: none;
            padding: 0;
        }

        .task-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: white;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: move;
        }

        .task-text {
            flex-grow: 1;
            cursor: pointer;
        }

        .task-description {
            font-size: 0.8em;
            color: #666;
            margin-top: 4px;
        }

        .task-item:hover {
            background: #f9f9f9;
        }

        .task-checkbox {
            margin-right: 10px;
        }

        .dragging {
            opacity: 0.5;
        }

        #status {
            color: #666;
            font-size: 0.9em;
            margin-top: 10px;
            text-align: center;
        }

        /* Dialog styles */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
        }

        .dialog {
            background: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
        }

        .dialog input,
        .dialog textarea {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .dialog textarea {
            height: 100px;
            resize: vertical;
        }

        .dialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .dialog-buttons button.cancel {
            background: #666;
        }
    </style>
</head>
<body>
<div class="todo-container">
    <h2>TODO List</h2>
    <div class="input-container">
        <input type="text" id="newTask" placeholder="Enter a new task">
        <button onclick="addTask()">Add Task</button>
    </div>
    <ul id="taskList" class="task-list">
    </ul>
    <div id="status"></div>
</div>

<!-- Edit Dialog -->
<div id="editDialog" class="dialog-overlay">
    <div class="dialog">
        <h3>Edit Task</h3>
        <input type="text" id="editTaskText" placeholder="Task title">
        <textarea id="editTaskDescription" placeholder="Task description"></textarea>
        <div class="dialog-buttons">
            <button class="cancel" onclick="closeEditDialog()">Cancel</button>
            <button onclick="saveEditedTask()">Save</button>
        </div>
    </div>
</div>

<script>
    let db = null;
    const DB_NAME = 'TodoDB';
    const STORE_NAME = 'todos';
    let currentEditingId = null;

    // Initialize database connection
    initDB().catch(error => {
        console.error('Database initialization failed:', error);
        showStatus('Database initialization failed', true);
    });

    async function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, 2); // Increased version number for schema update

            request.onerror = (event) => {
                console.error('Database error:', event.target.error);
                reject(event.target.error);
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                console.log('Database opened successfully');
                loadTasks();
                resolve(db);
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    const store = db.createObjectStore(STORE_NAME, {keyPath: 'id', autoIncrement: true});
                    store.createIndex('position', 'position', {unique: false});
                    // Add description field
                    store.createIndex('description', 'description', {unique: false});
                    console.log('Object store created');
                } else if (event.oldVersion < 2) {
                    // Add description field to existing store
                    const store = event.target.transaction.objectStore(STORE_NAME);
                    if (!store.indexNames.contains('description')) {
                        store.createIndex('description', 'description', {unique: false});
                    }
                }
            };
        });
    }

    function showStatus(message, isError = false) {
        const status = document.getElementById('status');
        status.textContent = message;
        status.style.color = isError ? '#ff4444' : '#666';
        setTimeout(() => {
            status.textContent = '';
        }, 3000);
    }

    async function loadTasks() {
        if (!db) {
            console.error('Database not initialized');
            return;
        }

        try {
            const transaction = db.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.getAll();

            request.onsuccess = () => {
                const tasks = request.result;
                const taskList = document.getElementById('taskList');
                taskList.innerHTML = '';

                tasks
                    .sort((a, b) => a.position - b.position)
                    .forEach(task => {
                        const li = createTaskElement(task);
                        taskList.appendChild(li);
                    });

                console.log('Tasks loaded:', tasks.length);
            };

            request.onerror = (event) => {
                console.error('Error loading tasks:', event.target.error);
                showStatus('Error loading tasks', true);
            };
        } catch (error) {
            console.error('Error in loadTasks:', error);
            showStatus('Error loading tasks', true);
        }
    }

    async function addTask() {
        if (!db) {
            console.error('Database not initialized');
            showStatus('Database not ready', true);
            return;
        }

        const input = document.getElementById('newTask');
        const taskText = input.value.trim();

        if (taskText === '') return;

        try {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);

            const countRequest = store.count();

            countRequest.onsuccess = () => {
                const position = countRequest.result;

                const task = {
                    text: taskText,
                    description: '',
                    position: position,
                    created: new Date().toISOString()
                };

                const addRequest = store.add(task);

                addRequest.onsuccess = (event) => {
                    const taskId = event.target.result;
                    task.id = taskId;
                    const taskList = document.getElementById('taskList');
                    const li = createTaskElement(task);
                    taskList.appendChild(li);
                    input.value = '';
                    showStatus('Task added successfully');
                };

                addRequest.onerror = (event) => {
                    console.error('Error adding task:', event.target.error);
                    showStatus('Error adding task', true);
                };
            };
        } catch (error) {
            console.error('Error in addTask:', error);
            showStatus('Error adding task', true);
        }
    }

    function createTaskElement(task) {
        const li = document.createElement('li');
        li.className = 'task-item';
        li.draggable = true;
        li.dataset.id = task.id;
        li.dataset.position = task.position;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'task-checkbox';
        checkbox.onclick = function () {
            if (this.checked) {
                deleteTask(task.id);
            }
        };

        const textContainer = document.createElement('div');
        textContainer.className = 'task-text';
        textContainer.onclick = () => openEditDialog(task);

        const titleSpan = document.createElement('span');
        titleSpan.textContent = task.text;

        textContainer.appendChild(titleSpan);

        const descSpan = document.createElement('div');
        descSpan.className = 'task-description';
        descSpan.textContent = task.description;
        textContainer.appendChild(descSpan);

        li.appendChild(checkbox);
        li.appendChild(textContainer);

        li.addEventListener('dragstart', handleDragStart);
        li.addEventListener('dragend', handleDragEnd);
        li.addEventListener('dragover', handleDragOver);
        li.addEventListener('drop', handleDrop);

        return li;
    }

    function openEditDialog(task) {
        currentEditingId = task.id;
        const dialog = document.getElementById('editDialog');
        const taskText = document.getElementById('editTaskText');
        const taskDesc = document.getElementById('editTaskDescription');

        taskText.value = task.text;
        taskDesc.value = task.description || '';

        dialog.style.display = 'flex';
    }

    function closeEditDialog() {
        const dialog = document.getElementById('editDialog');
        dialog.style.display = 'none';
        currentEditingId = null;
    }

    async function saveEditedTask() {
        if (!db || !currentEditingId) return;

        const taskText = document.getElementById('editTaskText').value.trim();
        const taskDesc = document.getElementById('editTaskDescription').value.trim();

        if (taskText === '') return;

        try {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get(currentEditingId);

            request.onsuccess = () => {
                const task = request.result;
                task.text = taskText;
                task.description = taskDesc;

                store.put(task).onsuccess = () => {
                    loadTasks();
                    closeEditDialog();
                    showStatus('Task updated successfully');
                };
            };
        } catch (error) {
            console.error('Error saving edited task:', error);
            showStatus('Error updating task', true);
        }
    }

    async function deleteTask(id) {
        if (!db) return;

        try {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.delete(id);

            request.onsuccess = () => {
                const element = document.querySelector(`[data-id="${id}"]`);
                if (element) {
                    element.remove();
                }
                showStatus('Task removed successfully');
            };

            request.onerror = (event) => {
                console.error('Error deleting task:', event.target.error);
                showStatus('Error removing task', true);
            };
        } catch (error) {
            console.error('Error in deleteTask:', error);
            showStatus('Error removing task', true);
        }
    }

    async function updatePositions() {
        if (!db) return;

        try {
            const taskList = document.getElementById('taskList');
            const items = Array.from(taskList.children);
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);

            for (let index = 0; index < items.length; index++) {
                const item = items[index];
                const id = parseInt(item.dataset.id);
                const request = store.get(id);

                request.onsuccess = () => {
                    const task = request.result;
                    if (task) {
                        task.position = index;
                        store.put(task);
                    }
                };
            }

            transaction.oncomplete = () => {
                console.log('Positions updated successfully');
                showStatus('Order updated');
            };
        } catch (error) {
            console.error('Error updating positions:', error);
            showStatus('Error updating order', true);
        }
    }

    let draggedItem = null;

    function handleDragStart(e) {
        draggedItem = this;
        this.classList.add('dragging');
    }

    function handleDragEnd(e) {
        this.classList.remove('dragging');
        updatePositions();
    }

    function handleDragOver(e) {
        e.preventDefault();
    }

    function handleDrop(e) {
        e.preventDefault();
        if (this === draggedItem) return;

        let taskList = document.getElementById('taskList');
        let children = Array.from(taskList.children);
        let draggedIndex = children.indexOf(draggedItem);
        let droppedIndex = children.indexOf(this);

        if (draggedIndex < droppedIndex) {
            this.parentNode.insertBefore(draggedItem, this.nextSibling);
        } else {
            this.parentNode.insertBefore(draggedItem, this);
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('newTask').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addTask();
            }
        });

        // Add keyboard support for dialog
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeEditDialog();
            }
            if (e.key === 'Enter' && e.ctrlKey) {
                if (document.getElementById('editDialog').style.display === 'flex') {
                    saveEditedTask();
                }
            }
        });
    });
</script>
</body>
</html>